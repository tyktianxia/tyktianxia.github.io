---
title: v3注意事项
date: 2021-12-02 10:01:59
tags: JS Vue3
---
# vue3 爬坑self

1. ref & reactive

- 两者都是为普通变量添加响应式
- ref 处理基本数据类型；reactive 处理非基本数据类型（数组、对象等）；
- ref()的参数也可以是对象类型，底层会调用 reactive()
- ref 生成的代理，操作时需要.value;reactive 生成的代理对象，会自动解包，不需要.value;
- 在模板中使用 ref || reactive 生成的代理，均不需要.value, vue 会自动解析
- reactive代理对象的非嵌套key，对应的value，不是ref
- ref和reactive 底层不同

2. watch

- watch api

```
watch(
  数据源
  回调,
  {
    immediate: true,
    deep: true,
  }
);
```
- watch 监听响应性数据
- 数据源可以是 getter 函数，或者是一个 ref （ref | reactive | reactive对象的非嵌套对象）
- 数据源可以多个，用数组包裹即可
- 监听响应式对象时（比如，reactive()），要有一个由值构成的副本。否则newVal和oldValue都是proxy, oldValue的值不正确（至少看着是，等波源码）
- 副本如：`()=>[...arr]` || `()=>({...obj})`,这样会监听到正确的结果 (等波源码))
- 多个同步更改只会触发一次watch。 可以使用 await nextTick()避免。或者设置flush:'sync,(每次更改都会触发一次watch，不推荐)
-

3. watchEffect

- 和计算属性类似，
- 计算属性侧重结果，要有 return
- watchEffect 侧重过程，函数体依赖哪个变量，就监听哪个变量
- TODO 需深度理解
- [文档](https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#%E5%81%9C%E6%AD%A2%E4%BE%A6%E5%90%AC)


4. 注意事项
- 扩展运算符会丢失响应性，但只丢失第一层的响应性。如果是嵌套对象，扩展运算符运行之后，第二层及以下依旧保持响应性
- 使用reactive声明代理对象时，会深度转换，每一层的嵌套对象都会转换为reactive对象，但是非对象的不会转为ref();(等一个源码解析)
````
const y = reactive({ name: { zh: "ppp" }, age: 12 });
const u = { ...y };
console.log(isRef(y.age));  false
console.log(isReactive(y.name));  true 
console.log(isReactive(u.name));  true
````
5. updated钩子函数
- **由数据变更导致dom变更，才会触发这个钩子，v2一样**，即，数据更新不会导致dom变更，此钩子不会触发
----


## 其他

1. 扩展运算符

- ES6 新增的符号 ...[数组|字符串|对象]， 如果是对象时，要在外边加上{}，不然会报错。如 {...obj}
- 将数组、字符串在语法层面上展开

```
let str = 'abc'
let obj = {name:'yanzhi'}

...[1,2,3,4] => 1,2,3,4
...str = 'a','b','c'
{...obj}
```

- 可以用来拼装新变量，而不影响原有 如：

```
let obj2 = {...obj,age:12};
let arr2 = [...arr,9,0]
```
2. 箭头函数
- `const fun0 = ()=>true` 省略函数体括号{}及return
- `const fun0 = ()=>{return true}`
- `const fun0 = ()=>1+2`  表达式
- `const fun0 = ()=>({age:12})` // 返回一个对象（需要括号包裹返回对象）
- `const fun0 = ()=>{return {age:12}}` 
- 函数体括号{}及return 要么都有，要么都没有。

3. v3的响应性处理和v2的有点不同，需注意，走一波源码
